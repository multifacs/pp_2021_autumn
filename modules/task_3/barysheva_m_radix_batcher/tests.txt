TEST(RADIX_BATCHER, ODD_EVEN_MERGE) {
  int rank, num;
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  MPI_Comm_size(MPI_COMM_WORLD, &num);
  if (log2(num) == static_cast<int>(log2(num))) {
    if (rank == 0) {
      auto v1 = getRandomVector(128);
      auto v2 = getRandomVector(128);
      double* data1 = v1.data();
      floatRadixSort<double>(data1, 128);
      double* data2 = v2.data();
      floatRadixSort<double>(data2, 128);
      auto result = v1;
      result.insert(result.end(), v2.begin(), v2.end());
      oddEvenMerge(&result, result.size());
      for (int i = 0; i < static_cast<int>(result.size()) - 1; i++) {
        EXPECT_TRUE(result[i] <= result[i + 1]);
      }
    }
  }
}

TEST(RADIX_BATCHER, GLOBAL_MERGE) {
  int rank, num;
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  MPI_Comm_size(MPI_COMM_WORLD, &num);
  if (log2(num) == static_cast<int>(log2(num))) {
    if (rank == 0) {
      auto v1 = getRandomVector(32);
      auto v2 = getRandomVector(32);
      auto v3 = getRandomVector(32);
      auto v4 = getRandomVector(32);
      double* data1 = v1.data();
      floatRadixSort<double>(data1, 32);
      double* data2 = v2.data();
      floatRadixSort<double>(data2, 32);
      double* data3 = v3.data();
      floatRadixSort<double>(data3, 32);
      double* data4 = v4.data();
      floatRadixSort<double>(data4, 32);
      std::vector<std::vector<double>> result;
      result.push_back(v1);
      result.push_back(v2);
      result.push_back(v3);
      result.push_back(v4);
      auto temp = merge(result);
      for (int i = 0; i < static_cast<int>(temp.size()) - 1; i++) {
        EXPECT_TRUE(temp[i] <= temp[i + 1]);
      }
    }
  }
}

TEST(RADIX_BATCHER, SMALL_DATA) {
  int rank, size;
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  MPI_Comm_size(MPI_COMM_WORLD, &size);
  if (log2(size) == static_cast<int>(log2(size)) && size <= 4) {
    std::vector<double> temp;
    if (rank == 0) {
      temp = getRandomVector(4);
    }
    temp = RadixSortParallel(temp, 4);
    if (rank == 0) {
      for (int i = 0; i < static_cast<int>(temp.size()) - 1; i++) {
        EXPECT_TRUE(temp[i] <= temp[i + 1]);
      }
    }
  }
}